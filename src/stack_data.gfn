<?xml version="1.0" encoding="UTF-8"?>
<gretl-functions>
<gretl-function-package name="stack_data" minver="2019b">
<author email="atecon@posteo.de">Artur Tarassow</author>
<version>0.9</version>
<date>2020-03-24</date>
<description>Stack list of series</description>
<tags>C81</tags>
<help>
Written by Artur Tarassow (please ask questions and report bugs on the gretl
mailing list if possible).

Source code and test script(s) can be found here:
https://github.com/atecon/stack

User-defined alternative to gretl's built-in stack() function. The built-in
function currently does not work within a loop-block and within a function-block as the active data set cannot be extended by additional observations in these cases.
The stack_data() package, however, does not support all the interesting functionalities of the built-in stack() function.
This package does the following:
Suppose one has two series, x1 and x2, for each T observations. The public function stack_data() compiles a data set that starts with a block for x1 with T rows followed by a block with the same structure for x2. Hence, the resulting series is a vertical concatenation of x1 and x2.

The sample script illustrates how the written stacked data set can be assembled into a panel via stack_data() plus gretl's built-in &quot;join&quot; command.


stack_data(L, filename, series_name, series_description):
--------------
Vertically stack data of L into a single series and store the resulting series. The stored data set includes three series: (1) &quot;unit_id&quot; is an identifier referring to the i-th stacked series, (2) &quot;obs_id&quot; is a unit-specific running number from 1 to T identifier, and (3) the stacked series itself.

Arguments:
List 			- list, List of series to stack
filename		- string, Full path plus filename where to store data set
series_name		- string, Name of compiled series (optional, default:
			&quot;stacked_series&quot;)
series_description	- string, Set the variable's descriptive label (optional,
			default: &quot;&quot;)

Return:
If the stacked data set is succesfully stored, return 0, 1 otherwise.


Changelog:
- v0.9, March 2020:
    + initial release
</help>
<gretl-function name="stack_data" type="scalar">
 <params count="4">
  <param name="L" type="list" const="true">
<description>List of series to stack</description>
  </param>
  <param name="filename" type="string" const="true">
<description>Full path + filename of new dataset</description>
  </param>
  <param name="series_name" type="string" optional="true" const="true">
<description>Name of constructed series</description>
  </param>
  <param name="series_description" type="string" optional="true" const="true">
<description>Description</description>
  </param>
 </params>
<code>/* Vertically stack data of L into a single series and
store the resulting series.
return: 0 if extended dataset is succesfully stored; 1 otherwise. */
if nelem(L) &lt; 2
  printf &quot;\nError: Input list needs at least two members.\n&quot;
  return 1
endif
if strlen(filename) == 0
  printf &quot;\nError: Invalid filename.\n&quot;
  return 1
endif
if !exists(series_name)
  string series_name = &quot;stacked_series&quot;
endif
if !exists(series_description)
  string series_description = &quot;&quot;
endif
setobs 1 1 --cross-section 		# reset eventual index
scalar T = $nobs
scalar n_L = nelem(L) - 1
scalar add_T = T * n_L
set skip_missing off			# NAs will not be dropped when converting from series to vector
matrix data_vector = vec({L})
set skip_missing on
catch dataset addobs add_T
if $error
  printf &quot;\nError: Failed to add new observations.\n&quot;
  return 1
endif
series @series_name = get_target_series(data_vector, series_name, series_description)
series unit_id = get_unit_id_series(L)
series obs_id = get_obs_id_series(L)
list FINAL = unit_id obs_id @series_name
scalar err_code = store_stacked_series(FINAL, filename)
return err_code
</code>
</gretl-function>
<gretl-function name="get_target_series" type="series" private="1">
 <params count="3">
  <param name="data_vector" type="matrix" const="true"/>
  <param name="series_name" type="string" const="true"/>
  <param name="series_description" type="string" const="true"/>
 </params>
<code>/* Convert vector to series and add a series description. */
genseries(series_name, data_vector)
setinfo @series_name --description=&quot;@series_description&quot;
return @series_name
</code>
</gretl-function>
<gretl-function name="get_obs_id_series" type="series" private="1">
 <params count="1">
  <param name="L" type="list" const="true"/>
 </params>
<code>/* Construct a running number from 1 to T where each
entry refers to the i-th observation of a unit. */
scalar k = nelem(L)
scalar T = $nobs / k			# length of each vector
series id = vec(seq(1,T)' .* ones(k)')
setinfo id --description=&quot;Time dimension&quot;
return id
</code>
</gretl-function>
<gretl-function name="get_unit_id_series" type="series" private="1">
 <params count="1">
  <param name="L" type="list" const="true"/>
 </params>
<code>/* Construct index indicating to which input series an observation
belongs to. */
scalar k = nelem(L)
scalar T = $nobs / k			# length of each vector
series id = vec(ones(T,k) .* seq(1,k))
setinfo id --description=&quot;Unit dimension&quot;
return id
</code>
</gretl-function>
<gretl-function name="store_stacked_series" type="scalar" private="1">
 <params count="2">
  <param name="L" type="list" const="true">
<description>ID and stacked series</description>
  </param>
  <param name="filename" type="string" const="true"/>
 </params>
<code>/* Store dataset with stacked series. */
catch store &quot;@filename&quot; L
scalar err_code = $error
if err_code
  printf &quot;\nError: %s\n&quot;, errmsg(err_code)
  return 1
endif
return 0
</code>
</gretl-function>
<sample-script>
set verbose off
clear

include stack_data.gfn

open denmark.gdt -q -p
list L = LRM LRY IBO
store &quot;time_series.gdt&quot; IDE
scalar T = $nobs

# Store stacked data
string filename = &quot;stacked_series.gdt&quot;
scalar error_code = stack_data(L, filename, &quot;some_new_var&quot;, &quot;some series description&quot;)

# CASE 1: Open stacked data and set a panel
open @filename -p -q
print unit_id obs_id -o
eval $nobs
setobs unit_id obs_id --panel-vars
append &quot;time_series.gdt&quot;				# Append 'macro' time-series which is replicated for all panel units


# CASE 2: Open existing panel data set and join stacked series
open grunfeld.gdt -q -p
join @filename some_new_var --ikey=firm,time --okey=unit_id,obs_id
print firm time invest some_new_var -o		# Valid observations offor the 1st three firms for 'some_new_var'
</sample-script>
</gretl-function-package>
</gretl-functions>
